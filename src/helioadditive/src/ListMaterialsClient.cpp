// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#include "ListMaterialsClient.h"

#include <algorithm>
#include <array>
#include <sstream>
#include <stdexcept>
#include <string_view>

using namespace std::literals;

namespace graphql::client {

using namespace query::ListMaterials;

static const std::array<std::string_view, 3> s_namesMaterialField = {
	"ID"sv,
	"NAME"sv,
	"BAMBUSTUDIO_NAME"sv,
};

static const std::array<std::string_view, 7> s_namesSimulationStatus = {
	"PENDING"sv,
	"INITIALIZING"sv,
	"SIMULATING"sv,
	"ARCHIVING"sv,
	"FINISHED"sv,
	"FAILED"sv,
	"STOPPED"sv,
};

template <>
response::Value ModifiedVariable<MaterialField>::serialize(MaterialField&& value)
{
	response::Value result { response::Type::EnumValue };

	result.set<response::StringType>(response::StringType { s_namesMaterialField[static_cast<size_t>(value)] });

	return result;
}

template <>
response::Value ModifiedVariable<SimulationStatus>::serialize(SimulationStatus&& value)
{
	response::Value result { response::Type::EnumValue };

	result.set<response::StringType>(response::StringType { s_namesSimulationStatus[static_cast<size_t>(value)] });

	return result;
}

template <>
response::Value ModifiedVariable<Variables::MaterialFilter>::serialize(Variables::MaterialFilter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(field)js"s, ModifiedVariable<MaterialField>::serialize(std::move(inputValue.field)));
	result.emplace_back(R"js(filter)js"s, ModifiedVariable<Filter>::serialize(std::move(inputValue.filter)));

	return result;
}

template <>
response::Value ModifiedVariable<Variables::StringFilter>::serialize(Variables::StringFilter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(equalTo)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.equalTo)));
	result.emplace_back(R"js(notEqualTo)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.notEqualTo)));
	result.emplace_back(R"js(caseSensitiveContains)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.caseSensitiveContains)));
	result.emplace_back(R"js(caseInsensitiveContains)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.caseInsensitiveContains)));
	result.emplace_back(R"js(caseSensitiveStartsWith)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.caseSensitiveStartsWith)));
	result.emplace_back(R"js(caseInsensitiveStartsWith)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.caseInsensitiveStartsWith)));
	result.emplace_back(R"js(caseSensitiveEndsWith)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.caseSensitiveEndsWith)));
	result.emplace_back(R"js(caseInsensitiveEndsWith)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.caseInsensitiveEndsWith)));
	result.emplace_back(R"js(notCaseSensitiveContains)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.notCaseSensitiveContains)));
	result.emplace_back(R"js(notCaseInsensitiveContains)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.notCaseInsensitiveContains)));
	result.emplace_back(R"js(notCaseSensitiveStartsWith)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.notCaseSensitiveStartsWith)));
	result.emplace_back(R"js(notCaseInsensitiveStartsWith)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.notCaseInsensitiveStartsWith)));
	result.emplace_back(R"js(notCaseSensitiveEndsWith)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.notCaseSensitiveEndsWith)));
	result.emplace_back(R"js(notCaseInsensitiveEndsWith)js"s, ModifiedVariable<response::StringType>::serialize<TypeModifier::Nullable>(std::move(inputValue.notCaseInsensitiveEndsWith)));

	return result;
}

template <>
response::Value ModifiedVariable<Variables::FloatFilter>::serialize(Variables::FloatFilter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(equalTo)js"s, ModifiedVariable<response::FloatType>::serialize<TypeModifier::Nullable>(std::move(inputValue.equalTo)));
	result.emplace_back(R"js(notEqualTo)js"s, ModifiedVariable<response::FloatType>::serialize<TypeModifier::Nullable>(std::move(inputValue.notEqualTo)));
	result.emplace_back(R"js(greaterThan)js"s, ModifiedVariable<response::FloatType>::serialize<TypeModifier::Nullable>(std::move(inputValue.greaterThan)));
	result.emplace_back(R"js(greaterThanOrEqualTo)js"s, ModifiedVariable<response::FloatType>::serialize<TypeModifier::Nullable>(std::move(inputValue.greaterThanOrEqualTo)));
	result.emplace_back(R"js(lessThan)js"s, ModifiedVariable<response::FloatType>::serialize<TypeModifier::Nullable>(std::move(inputValue.lessThan)));
	result.emplace_back(R"js(lessThanOrEqualTo)js"s, ModifiedVariable<response::FloatType>::serialize<TypeModifier::Nullable>(std::move(inputValue.lessThanOrEqualTo)));
	result.emplace_back(R"js(inList)js"s, ModifiedVariable<response::FloatType>::serialize<TypeModifier::Nullable, TypeModifier::List>(std::move(inputValue.inList)));
	result.emplace_back(R"js(notInList)js"s, ModifiedVariable<response::FloatType>::serialize<TypeModifier::Nullable, TypeModifier::List>(std::move(inputValue.notInList)));

	return result;
}

template <>
response::Value ModifiedVariable<Variables::IntFilter>::serialize(Variables::IntFilter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(equalTo)js"s, ModifiedVariable<response::IntType>::serialize<TypeModifier::Nullable>(std::move(inputValue.equalTo)));
	result.emplace_back(R"js(notEqualTo)js"s, ModifiedVariable<response::IntType>::serialize<TypeModifier::Nullable>(std::move(inputValue.notEqualTo)));
	result.emplace_back(R"js(greaterThan)js"s, ModifiedVariable<response::IntType>::serialize<TypeModifier::Nullable>(std::move(inputValue.greaterThan)));
	result.emplace_back(R"js(greaterThanOrEqualTo)js"s, ModifiedVariable<response::IntType>::serialize<TypeModifier::Nullable>(std::move(inputValue.greaterThanOrEqualTo)));
	result.emplace_back(R"js(lessThan)js"s, ModifiedVariable<response::IntType>::serialize<TypeModifier::Nullable>(std::move(inputValue.lessThan)));
	result.emplace_back(R"js(lessThanOrEqualTo)js"s, ModifiedVariable<response::IntType>::serialize<TypeModifier::Nullable>(std::move(inputValue.lessThanOrEqualTo)));
	result.emplace_back(R"js(inList)js"s, ModifiedVariable<response::IntType>::serialize<TypeModifier::Nullable, TypeModifier::List>(std::move(inputValue.inList)));
	result.emplace_back(R"js(notInList)js"s, ModifiedVariable<response::IntType>::serialize<TypeModifier::Nullable, TypeModifier::List>(std::move(inputValue.notInList)));

	return result;
}

template <>
response::Value ModifiedVariable<Variables::BooleanFilter>::serialize(Variables::BooleanFilter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(equalTo)js"s, ModifiedVariable<response::BooleanType>::serialize<TypeModifier::Nullable>(std::move(inputValue.equalTo)));
	result.emplace_back(R"js(notEqualTo)js"s, ModifiedVariable<response::BooleanType>::serialize<TypeModifier::Nullable>(std::move(inputValue.notEqualTo)));

	return result;
}

template <>
response::Value ModifiedVariable<Variables::SimulationStatusFilter>::serialize(Variables::SimulationStatusFilter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(equalTo)js"s, ModifiedVariable<SimulationStatus>::serialize<TypeModifier::Nullable>(std::move(inputValue.equalTo)));
	result.emplace_back(R"js(notEqualTo)js"s, ModifiedVariable<SimulationStatus>::serialize<TypeModifier::Nullable>(std::move(inputValue.notEqualTo)));

	return result;
}

template <>
response::Value ModifiedVariable<Variables::Filter>::serialize(Variables::Filter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(stringFilter)js"s, ModifiedVariable<StringFilter>::serialize<TypeModifier::Nullable>(std::move(inputValue.stringFilter)));
	result.emplace_back(R"js(floatFilter)js"s, ModifiedVariable<FloatFilter>::serialize<TypeModifier::Nullable>(std::move(inputValue.floatFilter)));
	result.emplace_back(R"js(intFilter)js"s, ModifiedVariable<IntFilter>::serialize<TypeModifier::Nullable>(std::move(inputValue.intFilter)));
	result.emplace_back(R"js(booleanFilter)js"s, ModifiedVariable<BooleanFilter>::serialize<TypeModifier::Nullable>(std::move(inputValue.booleanFilter)));
	result.emplace_back(R"js(statusFilter)js"s, ModifiedVariable<SimulationStatusFilter>::serialize<TypeModifier::Nullable>(std::move(inputValue.statusFilter)));

	return result;
}

template <>
MaterialField ModifiedResponse<MaterialField>::parse(response::Value&& value)
{
	if (!value.maybe_enum())
	{
		throw std::logic_error { "not a valid MaterialField value" };
	}

	const auto itr = std::find(s_namesMaterialField.cbegin(), s_namesMaterialField.cend(), value.release<response::StringType>());

	if (itr == s_namesMaterialField.cend())
	{
		throw std::logic_error { "not a valid MaterialField value" };
	}

	return static_cast<MaterialField>(itr - s_namesMaterialField.cbegin());
}

template <>
SimulationStatus ModifiedResponse<SimulationStatus>::parse(response::Value&& value)
{
	if (!value.maybe_enum())
	{
		throw std::logic_error { "not a valid SimulationStatus value" };
	}

	const auto itr = std::find(s_namesSimulationStatus.cbegin(), s_namesSimulationStatus.cend(), value.release<response::StringType>());

	if (itr == s_namesSimulationStatus.cend())
	{
		throw std::logic_error { "not a valid SimulationStatus value" };
	}

	return static_cast<SimulationStatus>(itr - s_namesSimulationStatus.cbegin());
}

template <>
Response::materials_PaginatedResponse::pageInfo_PageInfo ModifiedResponse<Response::materials_PaginatedResponse::pageInfo_PageInfo>::parse(response::Value&& response)
{
	Response::materials_PaginatedResponse::pageInfo_PageInfo result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(hasPreviousPage)js"sv)
			{
				result.hasPreviousPage = ModifiedResponse<response::BooleanType>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(hasNextPage)js"sv)
			{
				result.hasNextPage = ModifiedResponse<response::BooleanType>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle::brand_MaterialBrand ModifiedResponse<Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle::brand_MaterialBrand>::parse(response::Value&& response)
{
	Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle::brand_MaterialBrand result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(id)js"sv)
			{
				result.id = ModifiedResponse<response::IdType>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(name)js"sv)
			{
				result.name = ModifiedResponse<response::StringType>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle ModifiedResponse<Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle>::parse(response::Value&& response)
{
	Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(id)js"sv)
			{
				result.id = ModifiedResponse<response::IdType>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(name)js"sv)
			{
				result.name = ModifiedResponse<response::StringType>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(brand)js"sv)
			{
				result.brand = ModifiedResponse<Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle::brand_MaterialBrand>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
Response::materials_PaginatedResponse ModifiedResponse<Response::materials_PaginatedResponse>::parse(response::Value&& response)
{
	Response::materials_PaginatedResponse result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(pages)js"sv)
			{
				result.pages = ModifiedResponse<response::IntType>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(pageInfo)js"sv)
			{
				result.pageInfo = ModifiedResponse<Response::materials_PaginatedResponse::pageInfo_PageInfo>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(objects)js"sv)
			{
				result.objects = ModifiedResponse<Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle>::parse<TypeModifier::List>(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

namespace query::ListMaterials {

const std::string& GetRequestText() noexcept
{
	static const auto s_request = R"gql(
		query ListMaterials($page: Int, $pageSize: Int, $filters: [MaterialFilter!]) {
		  materials(page: $page, pageSize: $pageSize, filters: $filters) {
		    pages
		    pageInfo {
		      hasPreviousPage
		      hasNextPage
		    }
		    objects {
		      ... on Material {
		        id
		        name
		        brand {
		          id
		          name
		        }
		      }
		    }
		  }
		}
	)gql"s;

	return s_request;
}

const peg::ast& GetRequestObject() noexcept
{
	static const auto s_request = []() noexcept {
		auto ast = peg::parseString(GetRequestText());

		// This has already been validated against the schema by clientgen.
		ast.validated = true;

		return ast;
	}();

	return s_request;
}

response::Value serializeVariables(Variables&& variables)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(page)js"s, ModifiedVariable<response::IntType>::serialize<TypeModifier::Nullable>(std::move(variables.page)));
	result.emplace_back(R"js(pageSize)js"s, ModifiedVariable<response::IntType>::serialize<TypeModifier::Nullable>(std::move(variables.pageSize)));
	result.emplace_back(R"js(filters)js"s, ModifiedVariable<Variables::MaterialFilter>::serialize<TypeModifier::Nullable, TypeModifier::List>(std::move(variables.filters)));

	return result;
}

Response parseResponse(response::Value&& response)
{
	Response result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(materials)js"sv)
			{
				result.materials = ModifiedResponse<Response::materials_PaginatedResponse>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

} // namespace query::ListMaterials
} // namespace graphql::client
