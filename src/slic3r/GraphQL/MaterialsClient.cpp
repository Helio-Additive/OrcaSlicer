// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#include "MaterialsClient.h"

#include "graphqlservice/internal/SortedMap.h"

#include <algorithm>
#include <array>
#include <sstream>
#include <stdexcept>
#include <string_view>
#include <utility>

using namespace std::literals;

namespace graphql::client {
namespace HelioAdditive {

const std::string& GetRequestText() noexcept
{
	static const auto s_request = R"gql(
		query ListMaterials($page: Int, $pageSize: Int, $filters: [MaterialFilter!]) {
		  materials(page: $page, pageSize: $pageSize, filters: $filters) {
		    pages
		    pageInfo {
		      hasPreviousPage
		      hasNextPage
		    }
		    objects {
		      ... on Material {
		        id
		        name
		        brand {
		          id
		          name
		        }
		      }
		    }
		  }
		}
	)gql"s;

	return s_request;
}

const peg::ast& GetRequestObject() noexcept
{
	static const auto s_request = []() noexcept {
		auto ast = peg::parseString(GetRequestText());

		// This has already been validated against the schema by clientgen.
		ast.validated = true;

		return ast;
	}();

	return s_request;
}

Filter::Filter() noexcept
	: stringFilter {}
	, floatFilter {}
	, intFilter {}
	, booleanFilter {}
	, statusFilter {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

Filter::Filter(
		std::unique_ptr<StringFilter> stringFilterArg,
		std::unique_ptr<FloatFilter> floatFilterArg,
		std::unique_ptr<IntFilter> intFilterArg,
		std::unique_ptr<BooleanFilter> booleanFilterArg,
		std::unique_ptr<SimulationStatusFilter> statusFilterArg) noexcept
	: stringFilter { std::move(stringFilterArg) }
	, floatFilter { std::move(floatFilterArg) }
	, intFilter { std::move(intFilterArg) }
	, booleanFilter { std::move(booleanFilterArg) }
	, statusFilter { std::move(statusFilterArg) }
{
}

Filter::Filter(const Filter& other)
	: stringFilter { ModifiedVariable<StringFilter>::duplicate<TypeModifier::Nullable>(other.stringFilter) }
	, floatFilter { ModifiedVariable<FloatFilter>::duplicate<TypeModifier::Nullable>(other.floatFilter) }
	, intFilter { ModifiedVariable<IntFilter>::duplicate<TypeModifier::Nullable>(other.intFilter) }
	, booleanFilter { ModifiedVariable<BooleanFilter>::duplicate<TypeModifier::Nullable>(other.booleanFilter) }
	, statusFilter { ModifiedVariable<SimulationStatusFilter>::duplicate<TypeModifier::Nullable>(other.statusFilter) }
{
}

Filter::Filter(Filter&& other) noexcept
	: stringFilter { std::move(other.stringFilter) }
	, floatFilter { std::move(other.floatFilter) }
	, intFilter { std::move(other.intFilter) }
	, booleanFilter { std::move(other.booleanFilter) }
	, statusFilter { std::move(other.statusFilter) }
{
}

Filter::~Filter()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

Filter& Filter::operator=(const Filter& other)
{
	return *this = Filter { other };
}

Filter& Filter::operator=(Filter&& other) noexcept
{
	stringFilter = std::move(other.stringFilter);
	floatFilter = std::move(other.floatFilter);
	intFilter = std::move(other.intFilter);
	booleanFilter = std::move(other.booleanFilter);
	statusFilter = std::move(other.statusFilter);

	return *this;
}

StringFilter::StringFilter() noexcept
	: equalTo {}
	, notEqualTo {}
	, caseSensitiveContains {}
	, caseInsensitiveContains {}
	, caseSensitiveStartsWith {}
	, caseInsensitiveStartsWith {}
	, caseSensitiveEndsWith {}
	, caseInsensitiveEndsWith {}
	, notCaseSensitiveContains {}
	, notCaseInsensitiveContains {}
	, notCaseSensitiveStartsWith {}
	, notCaseInsensitiveStartsWith {}
	, notCaseSensitiveEndsWith {}
	, notCaseInsensitiveEndsWith {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

StringFilter::StringFilter(
		std::optional<std::string> equalToArg,
		std::optional<std::string> notEqualToArg,
		std::optional<std::string> caseSensitiveContainsArg,
		std::optional<std::string> caseInsensitiveContainsArg,
		std::optional<std::string> caseSensitiveStartsWithArg,
		std::optional<std::string> caseInsensitiveStartsWithArg,
		std::optional<std::string> caseSensitiveEndsWithArg,
		std::optional<std::string> caseInsensitiveEndsWithArg,
		std::optional<std::string> notCaseSensitiveContainsArg,
		std::optional<std::string> notCaseInsensitiveContainsArg,
		std::optional<std::string> notCaseSensitiveStartsWithArg,
		std::optional<std::string> notCaseInsensitiveStartsWithArg,
		std::optional<std::string> notCaseSensitiveEndsWithArg,
		std::optional<std::string> notCaseInsensitiveEndsWithArg) noexcept
	: equalTo { std::move(equalToArg) }
	, notEqualTo { std::move(notEqualToArg) }
	, caseSensitiveContains { std::move(caseSensitiveContainsArg) }
	, caseInsensitiveContains { std::move(caseInsensitiveContainsArg) }
	, caseSensitiveStartsWith { std::move(caseSensitiveStartsWithArg) }
	, caseInsensitiveStartsWith { std::move(caseInsensitiveStartsWithArg) }
	, caseSensitiveEndsWith { std::move(caseSensitiveEndsWithArg) }
	, caseInsensitiveEndsWith { std::move(caseInsensitiveEndsWithArg) }
	, notCaseSensitiveContains { std::move(notCaseSensitiveContainsArg) }
	, notCaseInsensitiveContains { std::move(notCaseInsensitiveContainsArg) }
	, notCaseSensitiveStartsWith { std::move(notCaseSensitiveStartsWithArg) }
	, notCaseInsensitiveStartsWith { std::move(notCaseInsensitiveStartsWithArg) }
	, notCaseSensitiveEndsWith { std::move(notCaseSensitiveEndsWithArg) }
	, notCaseInsensitiveEndsWith { std::move(notCaseInsensitiveEndsWithArg) }
{
}

StringFilter::StringFilter(const StringFilter& other)
	: equalTo { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.equalTo) }
	, notEqualTo { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.notEqualTo) }
	, caseSensitiveContains { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.caseSensitiveContains) }
	, caseInsensitiveContains { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.caseInsensitiveContains) }
	, caseSensitiveStartsWith { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.caseSensitiveStartsWith) }
	, caseInsensitiveStartsWith { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.caseInsensitiveStartsWith) }
	, caseSensitiveEndsWith { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.caseSensitiveEndsWith) }
	, caseInsensitiveEndsWith { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.caseInsensitiveEndsWith) }
	, notCaseSensitiveContains { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.notCaseSensitiveContains) }
	, notCaseInsensitiveContains { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.notCaseInsensitiveContains) }
	, notCaseSensitiveStartsWith { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.notCaseSensitiveStartsWith) }
	, notCaseInsensitiveStartsWith { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.notCaseInsensitiveStartsWith) }
	, notCaseSensitiveEndsWith { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.notCaseSensitiveEndsWith) }
	, notCaseInsensitiveEndsWith { ModifiedVariable<std::string>::duplicate<TypeModifier::Nullable>(other.notCaseInsensitiveEndsWith) }
{
}

StringFilter::StringFilter(StringFilter&& other) noexcept
	: equalTo { std::move(other.equalTo) }
	, notEqualTo { std::move(other.notEqualTo) }
	, caseSensitiveContains { std::move(other.caseSensitiveContains) }
	, caseInsensitiveContains { std::move(other.caseInsensitiveContains) }
	, caseSensitiveStartsWith { std::move(other.caseSensitiveStartsWith) }
	, caseInsensitiveStartsWith { std::move(other.caseInsensitiveStartsWith) }
	, caseSensitiveEndsWith { std::move(other.caseSensitiveEndsWith) }
	, caseInsensitiveEndsWith { std::move(other.caseInsensitiveEndsWith) }
	, notCaseSensitiveContains { std::move(other.notCaseSensitiveContains) }
	, notCaseInsensitiveContains { std::move(other.notCaseInsensitiveContains) }
	, notCaseSensitiveStartsWith { std::move(other.notCaseSensitiveStartsWith) }
	, notCaseInsensitiveStartsWith { std::move(other.notCaseInsensitiveStartsWith) }
	, notCaseSensitiveEndsWith { std::move(other.notCaseSensitiveEndsWith) }
	, notCaseInsensitiveEndsWith { std::move(other.notCaseInsensitiveEndsWith) }
{
}

StringFilter::~StringFilter()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

StringFilter& StringFilter::operator=(const StringFilter& other)
{
	return *this = StringFilter { other };
}

StringFilter& StringFilter::operator=(StringFilter&& other) noexcept
{
	equalTo = std::move(other.equalTo);
	notEqualTo = std::move(other.notEqualTo);
	caseSensitiveContains = std::move(other.caseSensitiveContains);
	caseInsensitiveContains = std::move(other.caseInsensitiveContains);
	caseSensitiveStartsWith = std::move(other.caseSensitiveStartsWith);
	caseInsensitiveStartsWith = std::move(other.caseInsensitiveStartsWith);
	caseSensitiveEndsWith = std::move(other.caseSensitiveEndsWith);
	caseInsensitiveEndsWith = std::move(other.caseInsensitiveEndsWith);
	notCaseSensitiveContains = std::move(other.notCaseSensitiveContains);
	notCaseInsensitiveContains = std::move(other.notCaseInsensitiveContains);
	notCaseSensitiveStartsWith = std::move(other.notCaseSensitiveStartsWith);
	notCaseInsensitiveStartsWith = std::move(other.notCaseInsensitiveStartsWith);
	notCaseSensitiveEndsWith = std::move(other.notCaseSensitiveEndsWith);
	notCaseInsensitiveEndsWith = std::move(other.notCaseInsensitiveEndsWith);

	return *this;
}

FloatFilter::FloatFilter() noexcept
	: equalTo {}
	, notEqualTo {}
	, greaterThan {}
	, greaterThanOrEqualTo {}
	, lessThan {}
	, lessThanOrEqualTo {}
	, inList {}
	, notInList {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

FloatFilter::FloatFilter(
		std::optional<double> equalToArg,
		std::optional<double> notEqualToArg,
		std::optional<double> greaterThanArg,
		std::optional<double> greaterThanOrEqualToArg,
		std::optional<double> lessThanArg,
		std::optional<double> lessThanOrEqualToArg,
		std::optional<std::vector<double>> inListArg,
		std::optional<std::vector<double>> notInListArg) noexcept
	: equalTo { std::move(equalToArg) }
	, notEqualTo { std::move(notEqualToArg) }
	, greaterThan { std::move(greaterThanArg) }
	, greaterThanOrEqualTo { std::move(greaterThanOrEqualToArg) }
	, lessThan { std::move(lessThanArg) }
	, lessThanOrEqualTo { std::move(lessThanOrEqualToArg) }
	, inList { std::move(inListArg) }
	, notInList { std::move(notInListArg) }
{
}

FloatFilter::FloatFilter(const FloatFilter& other)
	: equalTo { ModifiedVariable<double>::duplicate<TypeModifier::Nullable>(other.equalTo) }
	, notEqualTo { ModifiedVariable<double>::duplicate<TypeModifier::Nullable>(other.notEqualTo) }
	, greaterThan { ModifiedVariable<double>::duplicate<TypeModifier::Nullable>(other.greaterThan) }
	, greaterThanOrEqualTo { ModifiedVariable<double>::duplicate<TypeModifier::Nullable>(other.greaterThanOrEqualTo) }
	, lessThan { ModifiedVariable<double>::duplicate<TypeModifier::Nullable>(other.lessThan) }
	, lessThanOrEqualTo { ModifiedVariable<double>::duplicate<TypeModifier::Nullable>(other.lessThanOrEqualTo) }
	, inList { ModifiedVariable<double>::duplicate<TypeModifier::Nullable, TypeModifier::List>(other.inList) }
	, notInList { ModifiedVariable<double>::duplicate<TypeModifier::Nullable, TypeModifier::List>(other.notInList) }
{
}

FloatFilter::FloatFilter(FloatFilter&& other) noexcept
	: equalTo { std::move(other.equalTo) }
	, notEqualTo { std::move(other.notEqualTo) }
	, greaterThan { std::move(other.greaterThan) }
	, greaterThanOrEqualTo { std::move(other.greaterThanOrEqualTo) }
	, lessThan { std::move(other.lessThan) }
	, lessThanOrEqualTo { std::move(other.lessThanOrEqualTo) }
	, inList { std::move(other.inList) }
	, notInList { std::move(other.notInList) }
{
}

FloatFilter::~FloatFilter()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

FloatFilter& FloatFilter::operator=(const FloatFilter& other)
{
	return *this = FloatFilter { other };
}

FloatFilter& FloatFilter::operator=(FloatFilter&& other) noexcept
{
	equalTo = std::move(other.equalTo);
	notEqualTo = std::move(other.notEqualTo);
	greaterThan = std::move(other.greaterThan);
	greaterThanOrEqualTo = std::move(other.greaterThanOrEqualTo);
	lessThan = std::move(other.lessThan);
	lessThanOrEqualTo = std::move(other.lessThanOrEqualTo);
	inList = std::move(other.inList);
	notInList = std::move(other.notInList);

	return *this;
}

IntFilter::IntFilter() noexcept
	: equalTo {}
	, notEqualTo {}
	, greaterThan {}
	, greaterThanOrEqualTo {}
	, lessThan {}
	, lessThanOrEqualTo {}
	, inList {}
	, notInList {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

IntFilter::IntFilter(
		std::optional<int> equalToArg,
		std::optional<int> notEqualToArg,
		std::optional<int> greaterThanArg,
		std::optional<int> greaterThanOrEqualToArg,
		std::optional<int> lessThanArg,
		std::optional<int> lessThanOrEqualToArg,
		std::optional<std::vector<int>> inListArg,
		std::optional<std::vector<int>> notInListArg) noexcept
	: equalTo { std::move(equalToArg) }
	, notEqualTo { std::move(notEqualToArg) }
	, greaterThan { std::move(greaterThanArg) }
	, greaterThanOrEqualTo { std::move(greaterThanOrEqualToArg) }
	, lessThan { std::move(lessThanArg) }
	, lessThanOrEqualTo { std::move(lessThanOrEqualToArg) }
	, inList { std::move(inListArg) }
	, notInList { std::move(notInListArg) }
{
}

IntFilter::IntFilter(const IntFilter& other)
	: equalTo { ModifiedVariable<int>::duplicate<TypeModifier::Nullable>(other.equalTo) }
	, notEqualTo { ModifiedVariable<int>::duplicate<TypeModifier::Nullable>(other.notEqualTo) }
	, greaterThan { ModifiedVariable<int>::duplicate<TypeModifier::Nullable>(other.greaterThan) }
	, greaterThanOrEqualTo { ModifiedVariable<int>::duplicate<TypeModifier::Nullable>(other.greaterThanOrEqualTo) }
	, lessThan { ModifiedVariable<int>::duplicate<TypeModifier::Nullable>(other.lessThan) }
	, lessThanOrEqualTo { ModifiedVariable<int>::duplicate<TypeModifier::Nullable>(other.lessThanOrEqualTo) }
	, inList { ModifiedVariable<int>::duplicate<TypeModifier::Nullable, TypeModifier::List>(other.inList) }
	, notInList { ModifiedVariable<int>::duplicate<TypeModifier::Nullable, TypeModifier::List>(other.notInList) }
{
}

IntFilter::IntFilter(IntFilter&& other) noexcept
	: equalTo { std::move(other.equalTo) }
	, notEqualTo { std::move(other.notEqualTo) }
	, greaterThan { std::move(other.greaterThan) }
	, greaterThanOrEqualTo { std::move(other.greaterThanOrEqualTo) }
	, lessThan { std::move(other.lessThan) }
	, lessThanOrEqualTo { std::move(other.lessThanOrEqualTo) }
	, inList { std::move(other.inList) }
	, notInList { std::move(other.notInList) }
{
}

IntFilter::~IntFilter()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

IntFilter& IntFilter::operator=(const IntFilter& other)
{
	return *this = IntFilter { other };
}

IntFilter& IntFilter::operator=(IntFilter&& other) noexcept
{
	equalTo = std::move(other.equalTo);
	notEqualTo = std::move(other.notEqualTo);
	greaterThan = std::move(other.greaterThan);
	greaterThanOrEqualTo = std::move(other.greaterThanOrEqualTo);
	lessThan = std::move(other.lessThan);
	lessThanOrEqualTo = std::move(other.lessThanOrEqualTo);
	inList = std::move(other.inList);
	notInList = std::move(other.notInList);

	return *this;
}

BooleanFilter::BooleanFilter() noexcept
	: equalTo {}
	, notEqualTo {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

BooleanFilter::BooleanFilter(
		std::optional<bool> equalToArg,
		std::optional<bool> notEqualToArg) noexcept
	: equalTo { std::move(equalToArg) }
	, notEqualTo { std::move(notEqualToArg) }
{
}

BooleanFilter::BooleanFilter(const BooleanFilter& other)
	: equalTo { ModifiedVariable<bool>::duplicate<TypeModifier::Nullable>(other.equalTo) }
	, notEqualTo { ModifiedVariable<bool>::duplicate<TypeModifier::Nullable>(other.notEqualTo) }
{
}

BooleanFilter::BooleanFilter(BooleanFilter&& other) noexcept
	: equalTo { std::move(other.equalTo) }
	, notEqualTo { std::move(other.notEqualTo) }
{
}

BooleanFilter::~BooleanFilter()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

BooleanFilter& BooleanFilter::operator=(const BooleanFilter& other)
{
	return *this = BooleanFilter { other };
}

BooleanFilter& BooleanFilter::operator=(BooleanFilter&& other) noexcept
{
	equalTo = std::move(other.equalTo);
	notEqualTo = std::move(other.notEqualTo);

	return *this;
}

SimulationStatusFilter::SimulationStatusFilter() noexcept
	: equalTo {}
	, notEqualTo {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

SimulationStatusFilter::SimulationStatusFilter(
		std::optional<SimulationStatus> equalToArg,
		std::optional<SimulationStatus> notEqualToArg) noexcept
	: equalTo { std::move(equalToArg) }
	, notEqualTo { std::move(notEqualToArg) }
{
}

SimulationStatusFilter::SimulationStatusFilter(const SimulationStatusFilter& other)
	: equalTo { ModifiedVariable<SimulationStatus>::duplicate<TypeModifier::Nullable>(other.equalTo) }
	, notEqualTo { ModifiedVariable<SimulationStatus>::duplicate<TypeModifier::Nullable>(other.notEqualTo) }
{
}

SimulationStatusFilter::SimulationStatusFilter(SimulationStatusFilter&& other) noexcept
	: equalTo { std::move(other.equalTo) }
	, notEqualTo { std::move(other.notEqualTo) }
{
}

SimulationStatusFilter::~SimulationStatusFilter()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

SimulationStatusFilter& SimulationStatusFilter::operator=(const SimulationStatusFilter& other)
{
	return *this = SimulationStatusFilter { other };
}

SimulationStatusFilter& SimulationStatusFilter::operator=(SimulationStatusFilter&& other) noexcept
{
	equalTo = std::move(other.equalTo);
	notEqualTo = std::move(other.notEqualTo);

	return *this;
}

MaterialFilter::MaterialFilter() noexcept
	: field {}
	, filter {}
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

MaterialFilter::MaterialFilter(
		MaterialField fieldArg,
		Filter filterArg) noexcept
	: field { std::move(fieldArg) }
	, filter { std::move(filterArg) }
{
}

MaterialFilter::MaterialFilter(const MaterialFilter& other)
	: field { ModifiedVariable<MaterialField>::duplicate(other.field) }
	, filter { ModifiedVariable<Filter>::duplicate(other.filter) }
{
}

MaterialFilter::MaterialFilter(MaterialFilter&& other) noexcept
	: field { std::move(other.field) }
	, filter { std::move(other.filter) }
{
}

MaterialFilter::~MaterialFilter()
{
	// Explicit definition to prevent ODR violations when LTO is enabled.
}

MaterialFilter& MaterialFilter::operator=(const MaterialFilter& other)
{
	return *this = MaterialFilter { other };
}

MaterialFilter& MaterialFilter::operator=(MaterialFilter&& other) noexcept
{
	field = std::move(other.field);
	filter = std::move(other.filter);

	return *this;
}

} // namespace HelioAdditive

using namespace HelioAdditive;

template <>
response::Value Variable<MaterialField>::serialize(MaterialField&& value)
{
	static const std::array<std::string_view, 3> s_names = {
		R"gql(ID)gql"sv,
		R"gql(NAME)gql"sv,
		R"gql(BAMBUSTUDIO_NAME)gql"sv
	};

	response::Value result { response::Type::EnumValue };

	result.set<std::string>(std::string { s_names[static_cast<size_t>(value)] });

	return result;
}

template <>
response::Value Variable<SimulationStatus>::serialize(SimulationStatus&& value)
{
	static const std::array<std::string_view, 7> s_names = {
		R"gql(PENDING)gql"sv,
		R"gql(INITIALIZING)gql"sv,
		R"gql(SIMULATING)gql"sv,
		R"gql(ARCHIVING)gql"sv,
		R"gql(FINISHED)gql"sv,
		R"gql(FAILED)gql"sv,
		R"gql(STOPPED)gql"sv
	};

	response::Value result { response::Type::EnumValue };

	result.set<std::string>(std::string { s_names[static_cast<size_t>(value)] });

	return result;
}

template <>
response::Value Variable<Filter>::serialize(Filter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(stringFilter)js"s, ModifiedVariable<StringFilter>::serialize<TypeModifier::Nullable>(std::move(inputValue.stringFilter)));
	result.emplace_back(R"js(floatFilter)js"s, ModifiedVariable<FloatFilter>::serialize<TypeModifier::Nullable>(std::move(inputValue.floatFilter)));
	result.emplace_back(R"js(intFilter)js"s, ModifiedVariable<IntFilter>::serialize<TypeModifier::Nullable>(std::move(inputValue.intFilter)));
	result.emplace_back(R"js(booleanFilter)js"s, ModifiedVariable<BooleanFilter>::serialize<TypeModifier::Nullable>(std::move(inputValue.booleanFilter)));
	result.emplace_back(R"js(statusFilter)js"s, ModifiedVariable<SimulationStatusFilter>::serialize<TypeModifier::Nullable>(std::move(inputValue.statusFilter)));

	return result;
}

template <>
response::Value Variable<StringFilter>::serialize(StringFilter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(equalTo)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.equalTo)));
	result.emplace_back(R"js(notEqualTo)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.notEqualTo)));
	result.emplace_back(R"js(caseSensitiveContains)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.caseSensitiveContains)));
	result.emplace_back(R"js(caseInsensitiveContains)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.caseInsensitiveContains)));
	result.emplace_back(R"js(caseSensitiveStartsWith)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.caseSensitiveStartsWith)));
	result.emplace_back(R"js(caseInsensitiveStartsWith)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.caseInsensitiveStartsWith)));
	result.emplace_back(R"js(caseSensitiveEndsWith)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.caseSensitiveEndsWith)));
	result.emplace_back(R"js(caseInsensitiveEndsWith)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.caseInsensitiveEndsWith)));
	result.emplace_back(R"js(notCaseSensitiveContains)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.notCaseSensitiveContains)));
	result.emplace_back(R"js(notCaseInsensitiveContains)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.notCaseInsensitiveContains)));
	result.emplace_back(R"js(notCaseSensitiveStartsWith)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.notCaseSensitiveStartsWith)));
	result.emplace_back(R"js(notCaseInsensitiveStartsWith)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.notCaseInsensitiveStartsWith)));
	result.emplace_back(R"js(notCaseSensitiveEndsWith)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.notCaseSensitiveEndsWith)));
	result.emplace_back(R"js(notCaseInsensitiveEndsWith)js"s, ModifiedVariable<std::string>::serialize<TypeModifier::Nullable>(std::move(inputValue.notCaseInsensitiveEndsWith)));

	return result;
}

template <>
response::Value Variable<FloatFilter>::serialize(FloatFilter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(equalTo)js"s, ModifiedVariable<double>::serialize<TypeModifier::Nullable>(std::move(inputValue.equalTo)));
	result.emplace_back(R"js(notEqualTo)js"s, ModifiedVariable<double>::serialize<TypeModifier::Nullable>(std::move(inputValue.notEqualTo)));
	result.emplace_back(R"js(greaterThan)js"s, ModifiedVariable<double>::serialize<TypeModifier::Nullable>(std::move(inputValue.greaterThan)));
	result.emplace_back(R"js(greaterThanOrEqualTo)js"s, ModifiedVariable<double>::serialize<TypeModifier::Nullable>(std::move(inputValue.greaterThanOrEqualTo)));
	result.emplace_back(R"js(lessThan)js"s, ModifiedVariable<double>::serialize<TypeModifier::Nullable>(std::move(inputValue.lessThan)));
	result.emplace_back(R"js(lessThanOrEqualTo)js"s, ModifiedVariable<double>::serialize<TypeModifier::Nullable>(std::move(inputValue.lessThanOrEqualTo)));
	result.emplace_back(R"js(inList)js"s, ModifiedVariable<double>::serialize<TypeModifier::Nullable, TypeModifier::List>(std::move(inputValue.inList)));
	result.emplace_back(R"js(notInList)js"s, ModifiedVariable<double>::serialize<TypeModifier::Nullable, TypeModifier::List>(std::move(inputValue.notInList)));

	return result;
}

template <>
response::Value Variable<IntFilter>::serialize(IntFilter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(equalTo)js"s, ModifiedVariable<int>::serialize<TypeModifier::Nullable>(std::move(inputValue.equalTo)));
	result.emplace_back(R"js(notEqualTo)js"s, ModifiedVariable<int>::serialize<TypeModifier::Nullable>(std::move(inputValue.notEqualTo)));
	result.emplace_back(R"js(greaterThan)js"s, ModifiedVariable<int>::serialize<TypeModifier::Nullable>(std::move(inputValue.greaterThan)));
	result.emplace_back(R"js(greaterThanOrEqualTo)js"s, ModifiedVariable<int>::serialize<TypeModifier::Nullable>(std::move(inputValue.greaterThanOrEqualTo)));
	result.emplace_back(R"js(lessThan)js"s, ModifiedVariable<int>::serialize<TypeModifier::Nullable>(std::move(inputValue.lessThan)));
	result.emplace_back(R"js(lessThanOrEqualTo)js"s, ModifiedVariable<int>::serialize<TypeModifier::Nullable>(std::move(inputValue.lessThanOrEqualTo)));
	result.emplace_back(R"js(inList)js"s, ModifiedVariable<int>::serialize<TypeModifier::Nullable, TypeModifier::List>(std::move(inputValue.inList)));
	result.emplace_back(R"js(notInList)js"s, ModifiedVariable<int>::serialize<TypeModifier::Nullable, TypeModifier::List>(std::move(inputValue.notInList)));

	return result;
}

template <>
response::Value Variable<BooleanFilter>::serialize(BooleanFilter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(equalTo)js"s, ModifiedVariable<bool>::serialize<TypeModifier::Nullable>(std::move(inputValue.equalTo)));
	result.emplace_back(R"js(notEqualTo)js"s, ModifiedVariable<bool>::serialize<TypeModifier::Nullable>(std::move(inputValue.notEqualTo)));

	return result;
}

template <>
response::Value Variable<SimulationStatusFilter>::serialize(SimulationStatusFilter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(equalTo)js"s, ModifiedVariable<SimulationStatus>::serialize<TypeModifier::Nullable>(std::move(inputValue.equalTo)));
	result.emplace_back(R"js(notEqualTo)js"s, ModifiedVariable<SimulationStatus>::serialize<TypeModifier::Nullable>(std::move(inputValue.notEqualTo)));

	return result;
}

template <>
response::Value Variable<MaterialFilter>::serialize(MaterialFilter&& inputValue)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(field)js"s, ModifiedVariable<MaterialField>::serialize(std::move(inputValue.field)));
	result.emplace_back(R"js(filter)js"s, ModifiedVariable<Filter>::serialize(std::move(inputValue.filter)));

	return result;
}

template <>
MaterialField Response<MaterialField>::parse(response::Value&& value)
{
	if (!value.maybe_enum())
	{
		throw std::logic_error { R"ex(not a valid MaterialField value)ex" };
	}

	static const std::array<std::pair<std::string_view, MaterialField>, 3> s_values = {
		std::make_pair(R"gql(ID)gql"sv, MaterialField::ID),
		std::make_pair(R"gql(NAME)gql"sv, MaterialField::NAME),
		std::make_pair(R"gql(BAMBUSTUDIO_NAME)gql"sv, MaterialField::BAMBUSTUDIO_NAME)
	};

	const auto result = internal::sorted_map_lookup<internal::shorter_or_less>(
		s_values,
		std::string_view { value.get<std::string>() });

	if (!result)
	{
		throw std::logic_error { R"ex(not a valid MaterialField value)ex" };
	}

	return *result;
}

template <>
SimulationStatus Response<SimulationStatus>::parse(response::Value&& value)
{
	if (!value.maybe_enum())
	{
		throw std::logic_error { R"ex(not a valid SimulationStatus value)ex" };
	}

	static const std::array<std::pair<std::string_view, SimulationStatus>, 7> s_values = {
		std::make_pair(R"gql(FAILED)gql"sv, SimulationStatus::FAILED),
		std::make_pair(R"gql(PENDING)gql"sv, SimulationStatus::PENDING),
		std::make_pair(R"gql(STOPPED)gql"sv, SimulationStatus::STOPPED),
		std::make_pair(R"gql(FINISHED)gql"sv, SimulationStatus::FINISHED),
		std::make_pair(R"gql(ARCHIVING)gql"sv, SimulationStatus::ARCHIVING),
		std::make_pair(R"gql(SIMULATING)gql"sv, SimulationStatus::SIMULATING),
		std::make_pair(R"gql(INITIALIZING)gql"sv, SimulationStatus::INITIALIZING)
	};

	const auto result = internal::sorted_map_lookup<internal::shorter_or_less>(
		s_values,
		std::string_view { value.get<std::string>() });

	if (!result)
	{
		throw std::logic_error { R"ex(not a valid SimulationStatus value)ex" };
	}

	return *result;
}

template <>
query::ListMaterials::Response::materials_PaginatedResponse::pageInfo_PageInfo Response<query::ListMaterials::Response::materials_PaginatedResponse::pageInfo_PageInfo>::parse(response::Value&& response)
{
	query::ListMaterials::Response::materials_PaginatedResponse::pageInfo_PageInfo result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(hasPreviousPage)js"sv)
			{
				result.hasPreviousPage = ModifiedResponse<bool>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(hasNextPage)js"sv)
			{
				result.hasNextPage = ModifiedResponse<bool>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
query::ListMaterials::Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle::brand_MaterialBrand Response<query::ListMaterials::Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle::brand_MaterialBrand>::parse(response::Value&& response)
{
	query::ListMaterials::Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle::brand_MaterialBrand result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(id)js"sv)
			{
				result.id = ModifiedResponse<response::IdType>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(name)js"sv)
			{
				result.name = ModifiedResponse<std::string>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
query::ListMaterials::Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle Response<query::ListMaterials::Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle>::parse(response::Value&& response)
{
	query::ListMaterials::Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(id)js"sv)
			{
				result.id = ModifiedResponse<response::IdType>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(name)js"sv)
			{
				result.name = ModifiedResponse<std::string>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(brand)js"sv)
			{
				result.brand = ModifiedResponse<query::ListMaterials::Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle::brand_MaterialBrand>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

template <>
query::ListMaterials::Response::materials_PaginatedResponse Response<query::ListMaterials::Response::materials_PaginatedResponse>::parse(response::Value&& response)
{
	query::ListMaterials::Response::materials_PaginatedResponse result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(pages)js"sv)
			{
				result.pages = ModifiedResponse<int>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(pageInfo)js"sv)
			{
				result.pageInfo = ModifiedResponse<query::ListMaterials::Response::materials_PaginatedResponse::pageInfo_PageInfo>::parse(std::move(member.second));
				continue;
			}
			if (member.first == R"js(objects)js"sv)
			{
				result.objects = ModifiedResponse<query::ListMaterials::Response::materials_PaginatedResponse::objects_MaterialPrinterSimulationOptimizationEventGcodeFaqNewsArticle>::parse<TypeModifier::List>(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

namespace query::ListMaterials {

const std::string& GetOperationName() noexcept
{
	static const auto s_name = R"gql(ListMaterials)gql"s;

	return s_name;
}

response::Value serializeVariables(Variables&& variables)
{
	response::Value result { response::Type::Map };

	result.emplace_back(R"js(page)js"s, ModifiedVariable<int>::serialize<TypeModifier::Nullable>(std::move(variables.page)));
	result.emplace_back(R"js(pageSize)js"s, ModifiedVariable<int>::serialize<TypeModifier::Nullable>(std::move(variables.pageSize)));
	result.emplace_back(R"js(filters)js"s, ModifiedVariable<MaterialFilter>::serialize<TypeModifier::Nullable, TypeModifier::List>(std::move(variables.filters)));

	return result;
}

Response parseResponse(response::Value&& response)
{
	Response result;

	if (response.type() == response::Type::Map)
	{
		auto members = response.release<response::MapType>();

		for (auto& member : members)
		{
			if (member.first == R"js(materials)js"sv)
			{
				result.materials = ModifiedResponse<query::ListMaterials::Response::materials_PaginatedResponse>::parse(std::move(member.second));
				continue;
			}
		}
	}

	return result;
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetRequestText() noexcept
{
	return HelioAdditive::GetRequestText();
}

[[nodiscard("unnecessary call")]] const peg::ast& Traits::GetRequestObject() noexcept
{
	return HelioAdditive::GetRequestObject();
}

[[nodiscard("unnecessary call")]] const std::string& Traits::GetOperationName() noexcept
{
	return ListMaterials::GetOperationName();
}

[[nodiscard("unnecessary conversion")]] response::Value Traits::serializeVariables(Traits::Variables&& variables)
{
	return ListMaterials::serializeVariables(std::move(variables));
}

[[nodiscard("unnecessary conversion")]] Traits::Response Traits::parseResponse(response::Value&& response)
{
	return ListMaterials::parseResponse(std::move(response));
}

} // namespace query::ListMaterials
} // namespace graphql::client
